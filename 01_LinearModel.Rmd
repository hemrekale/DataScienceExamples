```{bash}
RETICULATE_MINICONDA_ENABLED=FALSE
```
```{python}
import os

```

<!-- http://r-statistics.co/Linear-Regression.html -->
  
Assumptions of linear regression:
    1- **Linearity**: The relationship between X and the mean of Y is linear.
    2 **Homoscedasticity**: The variance of residual is the same for any value of X.
    3- **Independence**: Observations are independent of each other.
Let's start with the built-in data set cars. cars data has 50 rows and two columns.

```{r}
setwd('/home/emre/fMRI/Codes_GH/DataScienceExamples')
head(cars)
str(cars)
```
# Exploratory Data Analysis

## Scatter Plot


```{r}
scatter.smooth(x=cars$speed, y=cars$dist, main="Dist ~ Speed",ylab = "Distance", xlab = "Speed")  # scatterplot
```
Plot shows there is a linear (the first assumption) and increasing relationship between two variables. 

## Box plot
```{r}
par(mfrow=c(1, 2))  # divide graph area in 2 columns
boxplot(cars$speed, main="Speed", sub=paste("Outlier value: ", boxplot.stats(cars$speed)$out))  # box plot for 'speed'
boxplot(cars$dist, main="Distance", sub=paste("Outlier value: ", boxplot.stats(cars$dist)$out))  # box plot for 'distance'

```

Distance has one outlier. Outliers can be detected usinq quantiles. 
IQR = 3rd Quantile - 1st Quantile
Outliers
For a value of independent variable (x) 
if x > 3rd Quantile + 1.5*IQR or if x < 1st Quantile - 1.5*IQR then x is outlier.

Now we check if there is outliers in data. We will use builtin **IQR** and **quantile** functions to create our own FindOutliersIQR() function.
**quantile** fucntion returns a named vector, and in our example the  for the speed variable **quantile** function print and return:

```{r}
q <-   quantile(cars$speed)
print(q)
```

For eg 1st Quantile can be obtained :

```{r}
q["25%"]
```

and IQR return the 3rdQuantile - 1stQuantile value:

```{r}
IQR(cars$speed)
```

The FindOutliersIQR function will use these functions and return outliers if there is any.

```{r}
FindOutliersIQR <- function(x) 
{
  x.quantile <- quantile(x) # cal
  x.IQR <- IQR(x)
  upper <- x.quantile["75%"]  + 1.5 * x.IQR
  lower <- x.quantile["25%"]  - 1.5 * x.IQR
  
  return(x[x < lower | x > upper])
}

speed.outliers <- FindOutliersIQR(cars$speed)
distance.outliers <- FindOutliersIQR(cars$dist)

print(paste0("Distance Outliers: ",distance.outliers))
print(paste0("Speed Outliers: ",speed.outliers))
```

It seems speed have one outlier value of 120

```{r}
par(mfrow=c(1, 2))  # divide graph area in 2 columns
hist(cars$speed, # histogram
 border="black",
 prob = TRUE, # show densities instead of frequencies
 xlab = "Speed",
 main = "Density and Histogram")
lines(density(cars$speed), # density plot
 lwd = 2, # thickness of line
 col = "blue")

hist(cars$dist, # histogram
 border="black",
 prob = TRUE, # show densities instead of frequencies
 xlab = "Distance",
 main = "Density and Histogram")
lines(density(cars$dist), # density plot
 lwd = 2, # thickness of line
 col = "blue")
#plot (density (cars$speed, na.rm=TRUE) )
```


# Linear Model

**lm** function calculates the parameters of the linear equation : intercept and slope of the linear model.

Distance = intercept + slope * Speed

```{r}
cars.lm <- lm(dist ~ speed, data=cars)
print(cars.lm)

```
Our estimated fit is then:
$$Distance =  -17.579    +  3.932 * Speed$$

```{r}
lm_eq <- function(model) {
  eq <-
    substitute((y) == a + b %.% (x) * "," ~  ~ (r) ^ 2 ~ "=" ~ r2,
               list(
                 a = format(unname(coef(model)[1]), digits = 2),
                 b = format(unname(coef(model)[2]), digits = 2),
                 r2 = format(summary(model)$r.squared, digits = 3)
               ))
  as.character(as.expression(eq))
}

print(lm_eq(cars.lm))
```
which means one unit change in speed increase distance 3.932 units.

```{r}

cars.lm.summary <- summary(cars.lm)
faramawy.summary <- faraway::sumary

faramawy.summary(cars.lm)

#xtxi <- cars.lm$cov.unscaled
#sqrt (diag (xtxi)) *cars.lm.sd

cars.lm.coefs <-cars.lm.summary$coefficients 
cars.lm.sd <- sqrt(deviance(cars.lm) / df.residual(cars.lm))

cars.lm.beta.estimate <- cars.lm.coefs["speed", "Estimate"]  # get beta estimate for speed
cars.lm.stderror <- cars.lm.coefs["speed", "Std. Error"]  # get std.error for speed

t_value <- cars.lm.beta.estimate/cars.lm.stderror  # calc t statistic
p_value <- 2*pt(-abs(t_value), df=nrow(cars)-ncol(cars))  

print(t_value)
print(p_value)

f_statistic <- cars.lm.summary$fstatistic[1]  # fstatistic
f <- cars.lm.summary$fstatistic  # parameters for model p-value calc
model_p <- pf(f[1], f[2], f[3], lower=FALSE)
print(model_p)
```

\newcommand*\mean[1]{\bar{#1}}

# Model Evaluation

## $R^2$ and $R^2_{adjusted}$
When the model assumptions for linear model is met then either $R^2$ or $R^2_{adjusted}$ can be used to measure goodness-of-fit
Remember sum of squares (SSE) is: 
$$SSE = \sum_i{(y_i - \hat{y_i})^2}{}$$
where $y_i$ is each data and $\hat{y}_i$ is the model value. And total sum of squares (SST)  is :
$$SST = \sum_i{(y_i - {\mean{y_i}})^2}{}$$
SST is basically variance of the data and SSE is the variance of the residuals (unexplained). Then $R^2$ is the explained variance to total variance of the data. The closer the $R^2$ to 1 is better.
$$R^2 = 1 - \frac{SSE}{SST}$$
$R^2$ value can be obtained from the summary of the model : 
```{r}
cars.lm.summary$r.squared
```

$R^2$ 


## Model fitting using linear algebra (optional)

Reference 1: http://r-statistics.co/Linear-Regression.html
  basic examples
Reference 2: From Faraday linear models with R
  linear algebra calculations
Reference 3: https://www.r-bloggers.com/2012/09/histogram-density-plot-combo-in-r/
  histograms

Calculate $$X^tX$$ and then $$\beta = {(X^tX)}^{-1}X^ty$$:
```{r}
X <- model.matrix ( ~ speed, data = cars)
y <- cars$dist
xtxi <- solve(t (X) %*% X)

beta <- solve (crossprod (X, X), crossprod (X, y))
cars.residuals <- y - X %*% beta 

hist(cars.residuals, # histogram
 border="black",
 prob = TRUE, # show densities instead of frequencies
 xlab = "Speed",
 main = "Density and Histogram")
lines(density(cars.residuals), # density plot
 lwd = 2, # thickness of line
 col = "blue")
```
```{r}
sd <- sqrt(crossprod(cars.lm.summary$residuals,cars.lm.summary$residuals)/48)
```

## Solve using QR decomposition

QR decomposition is a more stable method to solve equation.

Buraya farawayden ve HARPtan cozumu koyalim.




